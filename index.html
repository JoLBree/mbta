<!doctype html>
<html>
    <head></head>
    <title>MBTA timings</title>
    <style type="text/css">
        body {
            font-family: Arial;
            font-size: 250%;
        }
    </style>
    <body>
        <div id="message"></div>
        <div id="content"></div>
        <script type="text/javascript">
            var last_response_len = 0;
            var predictions = []
            var apiKey = getQueryVariable("api")
            var logDest = getQueryVariable("log")

            function logServer(message) {
                var xhttp = new XMLHttpRequest();
                xhttp.open("POST", "https://" + logDest + ".lambda-url.us-east-2.on.aws/", true);
                xhttp.setRequestHeader("Content-Type", "application/json");
                xhttp.onreadystatechange = function(event) {
                    // only update if it's the most recent request to have come back
                    if (xhttp.readyState == XMLHttpRequest.DONE) {
                        document.getElementById("message").innerText = xhttp.response
                    }
                };
                xhttp.send(JSON.stringify({ "message": message}));
                return xhttp
            }

            function getQueryVariable(variable) {
               var query = window.location.search.substring(1);
               var vars = query.split("&");
               for (var i=0;i<vars.length;i++) {
                   var pair = vars[i].split("=");
                   if(pair[0] == variable){return pair[1];}
               }
               return(false);
            }

            window.onerror = function (message, file, line, col, error) {
                var now = new Date()
                logServer("onerror ending execution" + error.message + " : " + message + " : " + file + " : " + file + " : " + line + " : " + col + " : " + pollNum + " : " + now);
                return false;
             };

             window.addEventListener("error", function (e) {
                var now = new Date()
                logServer("event error ending execution" + e.error.message + " : " + now);
                return false;
             })

            var testLog = logServer("Starting " + new Date() + " " + window.navigator.userAgent)
            testLog.onreadystatechange = function(event) {
                if (testLog.readyState == XMLHttpRequest.DONE) {
                    document.getElementById("message").innerText = testLog.response
                }
            };

            var xhttp = new XMLHttpRequest();
            xhttp.onerror = function(event) {
                var xhttpString = "";
                for (var key in xhttp) {
                    if (typeof xhttp[key] !== 'function') {
                        xhttpString += key + ":" + xhttp[key] + " ";
                    }
                }
                logServer("xhttp error ending execution" + new Date() + " : " + event + " : " + pollNum + " : " + xhttpString)
            }            
            xhttp.onprogress = function(event) {
                this_response = xhttp.response.substring(last_response_len);
                last_response_len = xhttp.response.length
                
                var events = parseResponse(this_response)
                document.getElementById("content").innerText = JSON.stringify(events)
            };
            xhttp.open("GET", "https://api-v3.mbta.com/predictions/?filter[stop]=12610&sort=arrival_time", true);
            // xhttp.open("GET", "https://api-v3.mbta.com/predictions/?filter[stop]=2664,2594&sort=arrival_time", true);
            xhttp.setRequestHeader('accept', 'text/event-stream')
            xhttp.setRequestHeader('x-api-key', apiKey)
            xhttp.send();

            function processEvents(events){
                for (var i = 0; i < events.length; i++) {
                    var event = events[i];
                    switch (event["event"]) {
                      case "reset":
                        predictions = "a"
                        break;
                      case event.startsWith(':'):
                        // ignore
                        break;
                      case event.includes(':'):
                        var splitIndex = event.indexOf(':');
                        field = {
                            "name": event.slice(0, splitIndex).trim(),
                            "value": event.slice(splitIndex+1).trim()
                        }
                        event = processField(field, event)
                        break;
                      default:
                        field = {
                            "name": event,
                            "value": ""
                        }
                        event = processField(field, event)
                    }
                }
            }

            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation
            function parseResponse(response) {
                var lines = response.split('\n');
                var events = [];
                var event = {}
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    switch (true) {
                      case line === '':
                        if ("event" in event){ // using this as a proxy for testing if empty, cheating the spec and expecting all events to have a name and not just data
                            events.push(event);
                        }
                        event = {}
                        break;
                      case line.startsWith(':'):
                        // ignore
                        break;
                      case line.includes(':'):
                        var splitIndex = line.indexOf(':');
                        field = {
                            "name": line.slice(0, splitIndex).trim(),
                            "value": line.slice(splitIndex+1).trim()
                        }
                        event = processField(field, event)
                        break;
                      default:
                        field = {
                            "name": line,
                            "value": ""
                        }
                        event = processField(field, event)
                    }
                }
                return events
            }

            // cutting corners with the spec to set instead of append, since the mbta api doesn't seem to send multi-line data events
            function processField(field, event){
                if (["event", "id"].indexOf(field["name"]) >= 0){
                    event[field["name"]] = field["value"]
                } else if (field["name"] === "data") {
                    event["data"] = JSON.parse(field["value"])
                } else {
                    // turn this into accumulated error messages
                    console.log("Unsupported field: " + JSON.stringify(field))
                }
                return event
            }
        </script>
    </body>
</html>
